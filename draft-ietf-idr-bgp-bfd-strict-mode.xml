<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?rfc toc="yes"?>
<?rfc tocompact="no"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="yes" ?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
     category="std" docName="draft-ietf-idr-bgp-bfd-strict-mode-13"
     ipr="trust200902"
     obsoletes=""
     updates="4271"
     submissionType="IETF"
     xml:lang="en"
     tocInclude="true"
     tocDepth="6"
     symRefs="true"
     sortRefs="true"
     consensus="true"
     version="3">
  <!-- xml2rfc v2v3 conversion 3.12.3 -->
  <!-- ***** FRONT MATTER ***** -->
  <front>
    <title abbrev="BGP BFD Strict-Mode ">BGP BFD Strict-Mode</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-idr-bgp-bfd-strict-mode-13"/>
    <author initials="M" surname="Zheng" fullname="Mercia Zheng">
      <organization>Ciena</organization>
      <address>
        <postal>
          <street>3939 N. 1st Street</street>
          <region>San Jose, CA 95134</region>
          <country>UNITED STATES</country>
        </postal>
        <phone/>
        <email>merciaz.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="A" surname="Lindem" fullname="Acee Lindem">
      <organization>LabN Consulting, L.L.C.</organization>
      <address>
        <postal>
          <street>301 Midenhall Way</street>
          <region>Cary, NC 27513</region>
          <country>UNITED STATES</country>
        </postal>
        <phone/>
        <email>acee.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="J" surname="Haas" fullname="Jeffrey Haas">
      <organization>Juniper Networks, Inc.</organization>
      <address>
        <postal>
          <street>1133 Innovation Way</street>
          <city>Sunnyvale</city>
          <region>CA</region>
          <code>94089</code>
          <country>USA</country>
        </postal>
        <phone/>
        <email>jhaas@juniper.net</email>
      </address>
    </author>
    <author initials="A" surname="Fu" fullname="Albert Fu">
      <organization>Bloomberg L.P.</organization>
      <address>
        <postal>
          <street>731 Lexington Avenue</street>
          <city>New York</city>
          <region>NY</region>
          <code>10022</code>
          <country>USA</country>
        </postal>
        <email>afu14@bloomberg.net</email>
      </address>
    </author>
    <date/>
    <area>Routing</area>
    <workgroup>IDR Workgroup</workgroup>
    <abstract>
      <t>
         This document specifies extensions to RFC4271 BGP-4 that enable a BGP speaker
         to negotiate additional Bidirectional Forwarding Detection (BFD) extensions using a
         BGP capability. This BFD Strict-Mode Capability enables a BGP speaker to prevent
         a BGP session from being established until a BFD session is established.
         This is referred to as BFD "strict-mode".
      </t>
    </abstract>
  </front>
  <!-- ***** MIDDLE MATTER ***** -->

  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
         Bidirectional Forwarding Detection BFD <xref target="RFC5880"/> enables routers to monitor
         data plane connectivity and to detect faults in the bidirectional forwarding path between them.
         This functionality is leveraged by routing protocols such as BGP <xref target="RFC4271" format="default"/> to rapidly
         react to topology changes in the face of path failures.
      </t>
      <t>
            The BFD interaction with BGP is specified in Section 10.2 of <xref target="RFC5882" format="default"/>.
            When BFD is enabled for a BGP neighbor, faults in the bidirectional forwarding detected by
            BFD result in BGP session termination. It is possible in some failure scenarios for the network to be
            in a state such that a BGP session may be established but a BFD session cannot be established.
            In some other scenarios, it may be possible to establish a BGP session, but a degraded or
            poor-quality link may result in the corresponding BFD session going up and down frequently.
      </t>
      <t>
            To avoid situations that result in routing churn and to minimize the impact of network
            interruptions, it will be beneficial to disallow BGP to establish a session until BFD session
            is successfully established and has stabilized. We refer to this mode of operation as BFD "strict-mode".
            However, always using "strict-mode" would preclude BGP operation in an environment where not all routers
            support BFD strict-mode or have BFD enabled.
      </t>
      <t>
            This document defines BFD "strict-mode" operation as
            preventing BGP session establishment until both the local and remote speakers have a stable BFD session.
            The document also specifies a BGP capability <xref target="RFC5492" format="default"/> for
            announcing BFD parameters including a BGP speaker's support for "strict-mode"; i.e., requiring a
            BFD session for BGP session establishment.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Requirements Language</name>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/>
        when, and only when, they appear in all capitals, as shown here.</t>
    </section>
    <section numbered="true" toc="default">
      <name>BFD Strict-Mode Capability Definition</name>
      <t>
           The BFD Strict-Mode Capability is a BGP Capability <xref target="RFC5492"/> defined as follows:
      </t>
      <t>
        Capability code: 74
      </t>
      <t>
        Capability length: 0 octets
      </t>
    </section>
    <section anchor="operation" numbered="true" toc="default">
      <name>BFD Strict-Mode Procedures</name>

      <section>
        <name>BFD Strict-Mode Capability Negotiation</name>
        <t>
            A BGP speaker which supports capabilities advertisement and has BFD strict-mode enabled
            MUST include the BFD Strict-Mode Capability in its OPEN message.
        </t>
        <t>
            A BGP speaker which supports the BFD Strict-Mode Capability examines the list
            of capabilities
            received from its peer. If both the local and remote BGP speakers include
            the BFD Strict-Mode Capability, the BfdStrictNegotiated session attribute
            (<xref target="session-attributes"/> below) is set to TRUE.
        </t>
      </section>
      <section>
        <name>BFD Strict-Mode BGP Finite State Machine Changes</name>

        <section anchor="session-attributes">
          <name>Session Attributes</name>

          <t>Defined in this document:</t>
          <dl newline="true">
          <dt>TBD-X) BfdEnabled:</dt>
          <dd>A boolean value that is TRUE when BFD is configured and enabled
              for this BGP session.</dd>
          <dt>TBD-X) BfdStrictEnabled:</dt>
          <dd>A boolean value that is TRUE when BGP BFD Strict-Mode procedures
              are to be used when BFD is enabled for this BGP session.  If
              BfdEnabled is not TRUE for this BGP session, this attribute has no
              impact.</dd>
          <dt>TBD-X) BfdHoldTimer:</dt>
          <dd>Hold timer used when the BGP HoldTime has been negotiated to zero
              to ensure the BGP session terminates if the associated BFD session
              does not enter the Up state.</dd>
          <dt>TBD-X) BfdHoldTime:</dt>
          <dd>Hold time value used for the BfdHoldTimer.  The default value for
              this attribute is 30 seconds and is user configurable.</dd>
          <dt>TBD-X) BfdStrictNegotiated:</dt>
          <dd>A boolean value that is TRUE when the BFD strict-mode feature
              capability has been successfully negotiated for this BGP session.</dd>
          </dl>

          <t>Defined in RFC 5880:</t>
          <dl newline="true">
          <dt>bfd.SessionState:</dt>
          <dd>The BFD session state associated with this BGP session when BFD
              is configured and enabled for the session.</dd>
          </dl>

        </section>
      </section>

      <section>
        <name>Events</name>

        <dl newline="true">
        <dt>Event TBD-X: BfdAdminDown</dt>
        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD session associated with this BGP session has
              transitioned to the AdminDown state.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>The BfdEnabled attribute for this BGP session SHOULD be set to
              TRUE.</dd>
          </dl>
        </dd>

        <dt>Event TBD-X: BfdDown</dt>

        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD session associated with this BGP session has
              transitioned to the Down state.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>The BfdEnabled attribute for this BGP session SHOULD be set to
              TRUE.</dd>
          </dl>
        </dd>

        <dt>Event TBD-X: BfdUp</dt>

        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD session associated with this BGP session has
              transitioned to the Up state.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>The BfdEnabled attribute for this BGP session SHOULD be set to
              TRUE.</dd>
          </dl>
        </dd>

        <dt>Event TBD-X: BfdHoldTimer_Expires</dt>
        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD holdtimer, which is set when the negotiated BGP hold
              time is zero, has expired.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>
          <ul>
          <li>The HoldTimer SHOULD NOT be running.</li>
          <li>The negotiated HoldTime SHOULD be zero.</li>
          <li>The BGP session state SHOULD be in Connect, Active, or OpenSent.</li>
          </ul>
          </dd>
          </dl>
        </dd>

        <dt>Event TBD-X: Bfd_Disabled</dt>
        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BfdEnabled session attribute has been changed to FALSE.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd></dd>
          </dl>
        </dd>

        <dt>Event TBD-X: BfdStrict_Disabled</dt>
        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD strict configuration for the BFD session has been
              disabled.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>The BfdEnabled attribute for this BGP session SHOULD be set to TRUE.
              If BfdEnabled is FALSE, this event MUST NOT occur.  Typically,
              disabling BFD for the session will trigger a BfdAdminDown event
              instead.
          </dd>
          </dl>
        </dd>

        <dt>Event TBD-X: BfdStrict_Enabled</dt>
        <dd>
          <dl newline="true">
          <dt>Definition:</dt>
          <dd>The BFD strict configuration for the BFD session has been
              enabled.</dd>

          <dt>Status:</dt>
          <dd>Optional</dd>

          <dt>Optional Attribute Status:</dt>
          <dd>The BfdEnabled attribute for this BGP session SHOULD be set to TRUE.</dd>
          </dl>
        </dd>
        </dl>
      </section>

      <section>
        <name>Changes to the FSM</name>

        <t>The following changes are made to section 8.2.2 in <xref target="RFC4271"/>:</t>

        <section>
          <name>Changes to the Idle State</name>

          <t>In the "Idle State", the BfdAdminDown, BfdDown, BfdUp,
             Bfd_Disabled, BfdStrict_Disabled, and BfdStrict_Enabled events are
             ignored.</t>

          <t>In the "Idle State", the BfdHoldTimer_Expires event is ignored, but
             only would occur as an error in the FSM implementation.</t>
        </section>

        <section>
          <name>Changes to the Connect State</name>

          <t>The BfdHoldTimer is reset to zero and stopped on any transition to the Idle state.</t>

          <section>
            <name>Handling Event 20, BGPOpen with DelayOpenTimer running.</name>

            <!-- XXX JMH - there's an implicit "and the open is acceptable" that's not mentioned here. -->
            <t>In the "Connect State", the handling of Event 20, an OPEN message
               is received while the DelayOpenTimer is running, is revised as
               follows:</t>

            <t>Old Text:</t>
            <ul>
            <li>stops the ConnectRetryTimer (if running) and sets the ConnectRetryTimer to zero,</li>
            <li>completes the BGP initialization,</li>
            <li>stops and clears the DelayOpenTimer (sets the value to zero),</li>
            <li>sends an OPEN message,</li>
            <li>sends a KEEPALIVE message,</li>
            <li><t>if the HoldTimer initial value is non-zero,</t>
              <ul>
              <li>starts the KeepaliveTimer with the initial value and</li>
              <li>resets the HoldTimer to the negotiated value,</li>
              </ul>
            </li>
            <li><t>else, if the HoldTimer initial value is zero,</t>
              <ul>
              <li>resets the KeepaliveTimer and</li>
              <li>resets the HoldTimer value to zero,</li>
              </ul>
            </li>
            <li>and changes its state to OpenConfirm.</li>
            </ul>
            <t>If the value of the autonomous system field is the same as the local
            Autonomous System number, set the connection status to an internal
            connection; otherwise it will be "external".</t>

            <t>New Text:</t>

            <ul>
            <li>stops the ConnectRetryTimer (if running) and sets the ConnectRetryTimer to zero,</li>
            <li>completes the BGP initialization,</li>
            <li>stops and clears the DelayOpenTimer (sets the value to zero),</li>
            <li>sends an OPEN message,</li>
            <li><t>If BfdEnabled is TRUE, and BfdStrictNegotiated is TRUE, and bfd.SessionState is neither Up nor AdminDown,</t>
              <ul>
              <li>DOES NOT send a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>DOES NOT start the KeepaliveTimer</li>
                <li>resets the HoldTimer to the negotiated value,</li> <!-- now we're waiting on a new holdtimer event -->
                </ul>
              </li>
              <li><t>else, if the HoldTimer initial value is zero,</t>
                <ul>
                <li>resets the KeepaliveTimer and</li>
                <li>resets the HoldTimer value to zero,</li>
                <li>starts the BfdHoldTimer with the value BfdHoldTime,</li>
                </ul>
              </li>
              <li>stays in the Connect state (enters BfdUpConnectPendingDelayOpen).</li>
              </ul>
            </li>
            <li><t>Else,</t>
              <ul>
              <li>sends a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>starts the KeepaliveTimer with the initial value and</li>
                <li>resets the HoldTimer to the negotiated value,</li>
                </ul>
              </li>
              <li><t>else, if the HoldTimer initial value is zero,</t>
                <ul>
                <li>resets the KeepaliveTimer and</li>
                <li>resets the HoldTimer value to zero,</li>
                </ul>
              </li>
              <li>and changes its state to OpenConfirm.</li>
              </ul>
            </li>
            </ul>
            <t>If the value of the autonomous system field is the same as the local
            Autonomous System number, set the connection status to an internal
            connection; otherwise it will be "external".</t>
          </section>

          <section>
            <name>Handling BfdDown</name>

            <t>The BfdDown event (Event TBD-X) is ignored while in the Connect
               state.</t>

            <t>A BFD session can transition to Down from the Init state,
               indicating the session has failed to come Up, or transition to
               Down from the AdminDown as part of starting the BFD state
               machine.</t>
          </section>

          <section>
            <name>Handling BfdAdminDown / Handling Bfd_Disabled / Handling BfdUp</name>

            <t>In response to the 
            BfdAdminDown event (Event TBD-X),
            the Bfd_Disabled event (Event TBD-X),
            or the BfdUp event (Event TBD-X) the
            the local system checks to see if it is in the
            BfdUpConnectPendingDelayOpen sub-state.  If the FSM is in the 
            BfdUpConnectPendingDelayOpen sub-state, the local system:</t>

            <ul>
              <li>sends a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>starts the KeepaliveTimer with the initial value and</li>
                <li>resets the BfdHoldTimer value to zero,</li>
                </ul>
              </li>
              <li>and changes its state to OpenConfirm (leaves BfdUpConnectPendingDelayOpen).</li>
            </ul>

            <t>If the FSM is not in the BfdUpConnectPendingDelayOpen sub-state,
               the local system:</t>
            <ul>
              <li>stays in the Connect state.</li>
            </ul>
          </section>

          <section>
            <name>Handling BfdHoldTimer_Expires</name>

            <t>In response to the BfdHoldTimer_Expires event (Event TBD-X), the local system:</t>

            <!-- Procedure copied from OpenSent transitioning to Idle on holdtime expires -->
            <ul>
              <li>sends a NOTIFICATION message with the error code Cease (6) and error subcode BFD Down (10),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>increments the ConnectRetryCounter,</li>
              <li>(optionally) performs peer oscillation damping if the DampPeerOscillations attribute is set to TRUE, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>

          <section>
            <name>Handling BfdStrict_Enabled / BfdStrict_Disabled</name>

            <t>In response to the BfdStrict_Enabled event (Event TBD-X) or
            the BfdStrict_Disabled event (Event TBD-X), the local system:</t>

            <!-- Procedure copies from Connect transitioning to Idle on Manual Stop -->
            <ul>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>sets ConnectRetryCounter to zero,</li>
              <li>stops the ConnectRetryTimer and sets ConnectRetryTimer to zero, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>

        </section>

        <section>
          <name>Changes to the Active State</name>
          <!-- the text here is effectively identical to the Connect state -->

          <t>The BfdHoldTimer is reset to zero and stopped for any transition to the Idle state.</t>

          <section>
            <name>Handling Event 20, BGPOpen with DelayOpenTimer running.</name>

            <!-- XXX JMH - there's an implicit "and the open is acceptable" that's not mentioned here. -->
            <t>In the "Active State", the handling of Event 20, an OPEN message
               is received while the DelayOpenTimer is running, is revised as
               follows:</t>

            <t>Old Text:</t>
            <ul>
            <li>stops the ConnectRetryTimer (if running) and sets the ConnectRetryTimer to zero,</li>
            <li>completes the BGP initialization,</li>
            <li>stops and clears the DelayOpenTimer (sets the value to zero),</li>
            <li>sends an OPEN message,</li>
            <li>sends a KEEPALIVE message,</li>
            <li><t>if the HoldTimer initial value is non-zero,</t>
              <ul>
              <li>starts the KeepaliveTimer with the initial value and</li>
              <li>resets the HoldTimer to the negotiated value,</li>
              </ul>
            </li>
            <li><t>else, if the HoldTimer initial value is zero,</t>
              <ul>
              <li>resets the KeepaliveTimer and</li>
              <li>resets the HoldTimer value to zero,</li>
              </ul>
            </li>
            <li>and changes its state to OpenConfirm.</li>
            </ul>
            <t>If the value of the autonomous system field is the same as the local
            Autonomous System number, set the connection status to an internal
            connection; otherwise it will be "external".</t>

            <t>New Text:</t>

            <ul>
            <li>stops the ConnectRetryTimer (if running) and sets the ConnectRetryTimer to zero,</li>
            <li>completes the BGP initialization,</li>
            <li>stops and clears the DelayOpenTimer (sets the value to zero),</li>
            <li>sends an OPEN message,</li>
            <li><t>If BfdEnabled is TRUE, and BfdStrictNegotiated is TRUE, and bfd.SessionState is neither Up nor AdminDown,</t>
              <ul>
              <li>DOES NOT send a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>DOES NOT start the KeepaliveTimer</li>
                <li>resets the HoldTimer to the negotiated value,</li> <!-- now we're waiting on a new holdtimer event -->
                </ul>
              </li>
              <li><t>else, if the HoldTimer initial value is zero,</t>
                <ul>
                <li>resets the KeepaliveTimer and</li>
                <li>resets the HoldTimer value to zero,</li>
                <li>starts the BfdHoldTimer with the value BfdHoldTime,</li>
                </ul>
              </li>
              <li>stays in the Active state (enters BfdUpActivePendingDelayOpen).</li>
              </ul>
            </li>
            <li><t>Else,</t>
              <ul>
              <li>sends a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>starts the KeepaliveTimer with the initial value and</li>
                <li>resets the HoldTimer to the negotiated value,</li>
                </ul>
              </li>
              <li><t>else, if the HoldTimer initial value is zero,</t>
                <ul>
                <li>resets the KeepaliveTimer and</li>
                <li>resets the HoldTimer value to zero,</li>
                </ul>
              </li>
              <li>and changes its state to OpenConfirm.</li>
              </ul>
            </li>
            </ul>
            <t>If the value of the autonomous system field is the same as the local
            Autonomous System number, set the connection status to an internal
            connection; otherwise it will be "external".</t>
          </section>

          <section>
            <name>Handling BfdDown</name>

            <t>The BfdDown event (Event TBD-X) is ignored while in the Active
               state.</t>

            <t>A BFD session can transition to Down from the Init state,
               indicating the session has failed to come Up, or transition to
               Down from the AdminDown as part of starting the BFD state
               machine.</t>
          </section>

          <section>
            <name>Handling BfdAdminDown / Handling Bfd_Disabled / Handling BfdUp</name>

            <t>In response to the
            BfdAdminDown event (Event TBD-X),
            the Bfd_Disabled event (Event TBD-X),
            or the BfdUp event (Event TBD-X),
            the local system checks to see if it is in the
            BfdUpActivePendingDelayOpen sub-state.  If the FSM is in the
            BfdUpActivePendingDelayOpen sub-state, the local system:</t>

            <ul>
              <li>sends a KEEPALIVE message,</li>
              <li><t>if the HoldTimer initial value is non-zero,</t>
                <ul>
                <li>starts the KeepaliveTimer with the initial value and</li>
                <li>resets the BfdHoldTimer value to zero,</li>
                </ul>
              </li>
              <li>and changes its state to OpenConfirm (leaves BfdUpActivePendingDelayOpen).</li>
            </ul>

            <t>If the FSM is not in the BfdUpActivePendingDelayOpen sub-state,
               the local system:</t>
            <ul>
              <li>stays in the Active state.</li>
            </ul>
          </section>

          <section>
            <name>Handling BfdHoldTimer_Expires</name>

            <t>In response to the BfdHoldTimer_Expires event (Event TBD-X), the local system:</t>

            <!-- Procedure copied from OpenSent transitioning to Idle on holdtime expires -->
            <ul>
              <li>sends a NOTIFICATION message with the error code Cease (6) and error subcode BFD Down (10),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>increments the ConnectRetryCounter,</li>
              <li>(optionally) performs peer oscillation damping if the DampPeerOscillations attribute is set to TRUE, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>

          <section>
            <name>Handling BfdStrict_Enabled / BfdStrict_Disabled</name>

            <t>In response to the BfdStrict_Enabled event (Event TBD-X) or
            the BfdStrict_Disabled event (Event TBD-X), the local system:</t>

            <!-- Procedure copies from Connect transitioning to Idle on Manual Stop -->
            <ul>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>sets ConnectRetryCounter to zero,</li>
              <li>stops the ConnectRetryTimer and sets ConnectRetryTimer to zero, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>
        </section>

        <section>
          <name>Changes to the OpenSent State</name>

          <t>The BfdHoldTimer is reset to zero and stopped for any transition to the Idle state.</t>

          <section>
            <name>Handling Event 19, BGPOpen</name>

            <t>Old Text:</t>
            <t>When an OPEN message is received, all fields are checked for
            correctness.  If there are no errors in the OPEN message (Event
            19), the local system:</t>

            <ul>
              <li>resets the DelayOpenTimer to zero,</li>
              <li>sets the BGP ConnectRetryTimer to zero,</li>
              <li>sends a KEEPALIVE message, and</li>
              <li>sets a KeepaliveTimer (via the text below)</li>
              <li>sets the HoldTimer according to the negotiated value (see Section 4.2), - changes its state to OpenConfirm.</li>
            </ul>
            <t>If the negotiated hold time value is zero, then the HoldTimer
            and KeepaliveTimer are not started.  If the value of the
            Autonomous System field is the same as the local Autonomous
            System number, then the connection is an "internal" connection;
            otherwise, it is an "external" connection.</t>

            <t>New Text:</t>
            <t>When an OPEN message is received, all fields are checked for
            correctness.  If there are no errors in the OPEN message (Event
            19), the local system:</t>

            <ul>
              <li>resets the DelayOpenTimer to zero,</li>
              <li>sets the BGP ConnectRetryTimer to zero,</li>
              <li>sets the HoldTimer according to the negotiated value (see Section 4.2), </li>
              <li><t>If BfdEnabled is TRUE, and BfdStrictNegotiated is TRUE,
                     and bfd.SessionState is neither Up nor AdminDown,</t>
                <ul>
                  <li>DOES NOT send a KEEPALIVE message, and</li>
                  <li>DOES NOT start the KeepaliveTimer</li>
                  <li><t>if the HoldTimer negotiated value is zero,</t>
                    <ul>
                      <li>starts the BfdHoldTimer with the value BfdHoldTime,</li>
                    </ul>
                  </li>
                  <li>stays in OpenSent state (BfdUpOpenSentPending)</li>
                </ul>
              </li>
              <li><t>Else,</t>
                <ul>
                  <li>sends a KEEPALIVE message, and</li>
                  <li>sets a KeepaliveTimer (via the text below)</li>
                  <li>changes its state to OpenConfirm.</li>
                </ul>
              </li>
            </ul>
            <t>If the negotiated hold time value is zero, then the HoldTimer
            and KeepaliveTimer are not started.  If the value of the
            Autonomous System field is the same as the local Autonomous
            System number, then the connection is an "internal" connection;
            otherwise, it is an "external" connection.</t>

          </section>

          <section>
            <name>Handling BfdAdminDown / Handling Bfd_Disabled / Handling BfdUp</name>

            <t>In response to the 
               the BfdAdminDown event (Event TBD-X),
               the Bfd_Disabled event (Event TBD-X),
               or the BfdUp event (Event TBD-X),
               and the FSM is in the BfdUpOpenSentPending sub-state, the local
               system:</t>

            <ul>
              <li>sends a KEEPALIVE message, and</li>
              <li>sets a KeepaliveTimer (via the text below)</li>
              <li>resets the BfdHoldTimer value to zero,</li>
              <li>changes its state to OpenConfirm (leaves BfdUpOpenSentPending).</li>
            </ul>
            
            <t>If the FSM is not in the BfdUpOpenSentPending sub-state, the
               local system:</t>
            <ul>
              <li>stays in the OpenSent state.</li>
            </ul>
          </section>

          <section>
            <name>Handling BfdHoldTimer_Expires</name>

            <t>In response to the BfdHoldTimer_Expires event (Event TBD-X), the local system:</t>

            <!-- Procedure copied from OpenSent transitioning to Idle on holdtime expires -->
            <ul>
              <li>sends a NOTIFICATION message with the error code Cease (6) and error subcode BFD Down (10),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>increments the ConnectRetryCounter,</li>
              <li>(optionally) performs peer oscillation damping if the DampPeerOscillations attribute is set to TRUE, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>

          <section>
            <name>Handling BfdStrict_Enabled / BfdStrict_Disabled</name>

            <t>In response to the BfdStrict_Enabled event (Event TBD-X) or
            the BfdStrict_Disabled event (Event TBD-X), the local system:</t>

            <!-- Procedure copies from OpenSent transitioning to Idle on Manual Stop -->
            <ul>
              <li>sends the NOTIFICATION with an error code Cease (6), error subcode Other Configuration Change (6),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>sets ConnectRetryCounter to zero,</li>
              <li>stops the ConnectRetryTimer and sets ConnectRetryTimer to zero, and</li>
              <li>changes its state to Idle.</li>
              <!-- Common procedure for leaving the state to stop the BfdHoldTimer -->
            </ul>
          </section>
        </section>

        <section>
          <name>Changes to the OpenConfirm State</name>

          <section>
            <name>Handling BfdDown</name>

            <t>In response to the BfdDown event (Event TBD-X), the local
               system:</t>
            <ul>
              <li>sends a NOTIFICATION message with the error code Cease (6) and error subcode BFD Down (10),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>sets ConnectRetryCounter to zero,</li>
              <li>stops the ConnectRetryTimer and sets ConnectRetryTimer to zero, and</li>
              <li>changes its state to Idle.</li>
            </ul>
          </section>

          <section>
            <name>Handling BfdAdminDown / Handling Bfd_Disabled / BfdUp</name>

            <t>The BfdAdminDown, Bfd_Disabled, and BfdUp events are
               ignored in the OpenConfirm state.</t>
          </section>

          <section>
            <name>Handling BfdStrict_Enabled / BfdStrict_Disabled</name>

            <t>In response to the BfdStrict_Enabled event (Event TBD-X) or
            the BfdStrict_Disabled event (Event TBD-X), the local system:</t>

            <ul>
              <li>sends a NOTIFICATION message with the error code Cease (6) and
                  error subcode Other Configuration Change (6),</li>
              <li>drops the TCP connection,</li>
              <li>releases all BGP resources,</li>
              <li>sets ConnectRetryCounter to zero,</li>
              <li>stops the ConnectRetryTimer and sets ConnectRetryTimer to zero, and</li>
              <li>changes its state to Idle.</li>
            </ul>
          </section>
        </section>

        <section>
          <name>Changes to the Established State</name>

          <section>
            <name>Handling BfdUp / Handling BfdAdminDown</name>

            <t>The BfdUp and BfdAdminDown events are ignored in the Established
            state.</t>
          </section>

          <section>
            <name>Handling BfdStrict_Enabled / BfdStrict_Disabled</name>

            <t>The BfdStrict_Enabled and BfdStrict_Disabled events are ignored
            in the Established state.</t>
          </section>
        </section>
      </section>

      <section numbered="true" toc="default">
        <name>Closing BGP Sessions</name>
        <t>
          When BGP sessions are closed according to the procedures in this document, the session
          SHOULD be terminated with a NOTIFICATION message with the Cease Code (6) and the "BFD Down"
          Subcode (10); see <xref target="RFC9384"/>.  This informs the operator that
          interaction with BFD is the root cause of the BGP session being unable to move to the
          Established state.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Stability Considerations</name>
        <t>
          The use of BFD strict-mode along with mechanisms such as
          hold-down (a delay in the initial BGP Establishment state following
          BFD session establishment) and/or dampening (a delay in the BGP
          Establishment state following failure detected by BFD) may help
          reduce the frequency of BGP session flaps and therefore reduce the
          associated routing churn.
        </t>
        <t>
          To avoid deadlock when utilizing both BFD hold-down and BFD
          strict-mode, when strict-mode is enabled for a peer, the BGP FSM MUST
          be enabled.  That is, BFD hold-down procedures MUST NOT prevent BGP from
          establishing a connection with the remote BGP speaker.
        </t>
        <t>
          If both the local and remote BGP speakers include the
          BFD Strict-Mode Capability, the BGP state machine is permitted to
          transition to the Established state from the OpenConfirm state after
          the locally configured BFD hold-down interval is observed.  That is,
          the BFD session has been Up for the desired amount of time.
        </t>
        <t>
          Implementations MAY start the BFD session associated with the BFD
          bfd-strict session prior to the BGP FSM starting.  Similarly,
          to support BFD hold-down requirements for detecting BFD session
          stability, implementations SHOULD NOT immediately destroy BFD sessions
          when associated BGP connections transition to Idle.
        </t>
        <t>
          It is RECOMMENDED that the BFD hold-down intervals used with BFD
          strict-mode, when configured, use similar values.  Similarly, the
          negotiated BGP holdtime SHOULD be long enough to account for the time
          between the BGP FSM reaching the OpenConfirm state, the BFD hold-down
          interval, and any delay for the BFD session being initiated.
          Failure to do so can result in the BGP speaker that has transitioned
          to the Established state expiring its BGP holdtime and closing the
          connection.  This is because the remote BGP speaker hasn't
          transitioned to Established and begun sending KEEPALIVE messages.
        </t>
        <t>
          A BGP speaker SHOULD log a message if it closes its session due to
          hold timer expiration while waiting for the BFD hold-down interval.
        </t>
        <t>
          The behavior of BGP speakers implementing BFD hold-down without
          negotiating the BFD strict-mode feature is out of scope of this
          document.  However, the authors are aware that inconsistent behaviors
          in BGP implementations for BFD hold-down without BFD strict-mode
          may result in BGP session deadlock.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Manageability Considerations</name>
      <t>
          Auto-configuration is possible for enabling BFD strict-mode. However,
          the configuration automation is out of the scope of this document.
      </t>
      <t>
          To simplify troubleshooting and avoid inconsistencies, it is RECOMMENDED that BFD strict-mode
          configuration be consistent for both BGP peers.
      </t>
      <t>
          An implementation's display of BGP finite state machine state SHOULD
          provide visibility for the OpenConfirm state that BFD Up and/or BGP
          KEEPALIVE's are pending.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
          The mechanism defined in this document interacts with the BGP finite state machine when so configured.
          The security considerations for BFD thus, become BGP-4 considerations <xref target="RFC4271" format="default"/>
          when so used. Given that a BFD session is required for a BGP session, a Denial-of-Service (DoS) attack on
          BGP can now be mounted by preventing a BFD session between the BGP peers from reaching the Up state,  or
          interrupting an existing BFD session.
          The use of a BFD Authentication mechanism, some of which are defined
          in <xref target="RFC5880" format="default"/>, is thus RECOMMENDED
          when used to protect BGP-4 <xref target="RFC4271" format="default"/>.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
        This document defines the BFD Strict-Mode Capability. The Capability Code 74 has been assigned from
        the First-Come-First-Served range (64-238) of the Capability Codes registry.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Acknowledgement</name>
      <t>
              The authors would like to acknowledge the review and inputs from Shyam Sethuram, Mohammed Mirza,
              Bruno Decraene, Carlos Pignataro, Enke Chen, Anup Kumar, and Ketan Talalukar.
      </t>
    </section>
  </middle>
  <!--  *****BACK MATTER ***** -->

  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4271.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5492.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5880.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5882.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9384.xml"/>
    </references>
  </back>
</rfc>
